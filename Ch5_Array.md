# Ch.5 배열(Array)
1. [배열](#)
    * [배열(array) 이란?](#배열(array)-이란?)
    * [1.2 배열의 선언과 생성](#1.2-배열의-선언과-생성)
    * [1.3 배열의 길이와 인덱스](#1.3-배열의-길이와-인덱스)
    * [1.4 배열의 초기화](#1.4-배열의-초기화)
    * [1.5 배열의 복사](#1.5-배열의-복사)
    * [1.6 배열의 활용](#1.6-배열의-활용)
2. [String 배열](#string-배열)
    * [2.1 String배열의 선언과 생성](#2.1-string배열의-선언과-생성)
    * [2.2 String배열의 초기화](#2.2-string배열의-초기화)
    * [2.3 char배열과 String클래스](#2.3-char배열과-string클래스)
    * [2.4 커맨드 라인을 통해 입력받기](#2.4-커맨드-라인을-통해-입력받기)
3. [다차원 배열](#다차원-배열)
    * [3.1 2차원 배열의 선언과 인덱스](#3.1-2차원-배열의-선언과-인덱스)
    * [3.2 2차원 배열의 초기화](#3.2-2차원-배열의-초기화)
    * [3.3 가변 배열](#3.3-가변-배열)
    * [3.4 다차원 배열의 활용](#3.4-다차원-배열의-활용)

   
## 배열(array) 이란?
같은 타입의 여러 변수를 하나의 묶음으로 다루는 것.  
서로 다른 타입의 변수들로 구성된 배열은 만들 수 없다.  
만일 배열을 사용하지 않는다면 학생 5명의 점수를 저장하기 위해서 아래와 같이  
5개의 변수를 선언해야 할 것이다.  
```java
int score1, score2, score3, score4, score5;
```
변수 대신 배열을 이용하면 다음과 같이 간단히 처리할 수 있다.  
```java
int[] score = new int[5]; //5개의 int값을 저장할 수 있는 배열을 생성한다.
```
값을 저장할 수 있는 공간은 score[0]부터 score[4]까지 모두 5개이며, 변수 score는  
배열을 다루는 데 필요한 참조변수일 뿐 값을 저장하기 위한 공간은 아니다.  
변수와 달리 ***배열은 각 저장공간이 연속적으로 배치***되어 있다는 특징이 있다.

### 1.2 배열의 선언과 생성
|  **선언방법**   |             **선언 예**              |
|:-----------:|:---------------------------------:|
| 타입[ ] 변수이름; | int[ ] score;<br/>String[ ] name; |
| 타입 변수이름[ ]; | int score[ ];<br/>String name[ ]; |  

배열을 선언한 뒤에는 배열을 생성해야 한다.  
배열을 선언하는 것은 단지 생성된 배열을 다루기 위한  
참조변수를 위한 공간이 만들어질 뿐이고, 배열을 생성해야만  
비로소 값을 저장할 수 있는 공간이 만들어지는 것이다.  
배열을 생성하기 위해서는 연산자 'new'와 함께 배열의 타입과 길이를 지정해 주어야 한다.

아래의 코드는 '길이가 5인 int배열'을 생성한다.
```java
int[] score;        //int타입의 배열을 다루기 위한 참조변수 score선언
score = new int[5]; //배열을 생성(실제 저장공간을 생성), 각 배열요소는 int의 기본값인 0으로 초기화 된다.
```

### 1.3 배열의 길이와 인덱스
생성된 배열의 각 저장공간을 '배열의 요소(element)'라고 하며, '배열이름[인덱스]'의 형태로 배열의 요소에 접근한다.
배열의 또 다른 장점은 index로 상수 대신 변수나 수식도 사용할 수 있다는 것이다.  
한 가지 주의할 점은 index의 범위를 벗어난 값을 index로 사용하지 않아야 한다는 것이다.  
유효한 범위를 벗어난 값을 index로 사용하는 것은 가장 흔한 실수이며, 컴파일러는 이러한 실수를 걸러내지 못한다  
배열의 index로 변수를 많이 사용하는데, 변수의 값은 실행 시에 대입되므로 컴파일러는 이 값의 범위를 확인할 수 없기 때문이다.  
유효하지 않은 값을 index로 사용하면, 무사히 컴파일을 마쳤더라도 실행 시에 에러(ArrayIndexOutOfBoundsException)가 발생한다.

```java
class ArrayEx1 {
   public static void main(String[] args) {
      int[] score = new int[5];
      int k = 1;

      score[0] = 50;
      score[1] = 60;
      score[k + 1] = 70;    // score[2] = 70
      score[3] = 80;
      score[4] = 90;

      int tmp = score[k+2] + score[4]; // int tmp = score[3] + score[4]

      for(int i=0; i<5; i++) {
         System.out.printf("score[%d]:%d%n",i,score[i]); // %d : 정수형식 출력,  %n : 줄바꿈
      }

      System.out.printf("tmp:%d%n", tmp);
      System.out.printf("score[%d]:%d%n",7,score[7]); //index의 범위를 벗어난 값
   }
}
```


